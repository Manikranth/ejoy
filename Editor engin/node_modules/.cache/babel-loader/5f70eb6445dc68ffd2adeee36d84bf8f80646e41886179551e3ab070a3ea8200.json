{"ast":null,"code":"var _jsxFileName = \"/Users/manikranthbheemineni/PlayGround/Ejoy/Editor engin/src/components/Canvas.jsx\",\n  _s = $RefreshSig$();\nimport React, { useCallback, useRef, useEffect, useState } from 'react';\nimport Element from './Element';\nimport './Canvas.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Canvas({\n  elements,\n  selectedElement,\n  setSelectedElement,\n  updateElement,\n  deleteElement,\n  isPreviewMode,\n  addElement,\n  getDefaultStyle,\n  deviceView\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  const [canvasBounds, setCanvasBounds] = useState({\n    left: 0,\n    right: 0,\n    top: null,\n    bottom: null,\n    width: 0\n  });\n\n  // Calculate and update canvas boundaries when component mounts or window resizes\n  useEffect(() => {\n    const updateCanvasBounds = () => {\n      if (canvasRef.current) {\n        const rect = canvasRef.current.getBoundingClientRect();\n\n        // Set bounds based on canvas container dimensions\n        setCanvasBounds({\n          left: rect.left,\n          right: rect.right,\n          // No vertical constraints for infinite scrolling\n          top: null,\n          bottom: null,\n          // Add the width to help with calculations\n          width: rect.width\n        });\n      }\n    };\n    updateCanvasBounds();\n    window.addEventListener('resize', updateCanvasBounds);\n    const observer = new MutationObserver(updateCanvasBounds);\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['style', 'class']\n    });\n    return () => {\n      window.removeEventListener('resize', updateCanvasBounds);\n      observer.disconnect();\n    };\n  }, []);\n\n  // Adjust canvas height based on elements and mode\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    if (isPreviewMode) {\n      canvasRef.current.style.paddingBottom = '0';\n    } else {\n      // In edit mode, ensure we have plenty of space at the bottom for adding new elements\n      let maxBottom = 0;\n      elements.forEach(element => {\n        const el = document.getElementById(`element-${element.id}`);\n        if (el) {\n          const bottom = element.position.y + el.offsetHeight;\n          maxBottom = Math.max(maxBottom, bottom);\n        }\n      });\n\n      // Set minimum height to be greater of viewport height or content + padding\n      const minHeight = Math.max(window.innerHeight, maxBottom + 300);\n      canvasRef.current.style.minHeight = `${minHeight}px`;\n      canvasRef.current.style.paddingBottom = '200px';\n    }\n  }, [elements, isPreviewMode]);\n\n  // Add a useEffect to handle canvas resizing based on device view\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    const container = canvasRef.current.parentElement;\n\n    // Set width based on device type\n    switch (deviceView) {\n      case 'desktop':\n        container.style.width = '100%';\n        container.style.maxWidth = '1140px';\n        break;\n      case 'tablet':\n        container.style.width = '768px';\n        container.style.maxWidth = '768px';\n        break;\n      case 'mobile':\n        container.style.width = '375px';\n        container.style.maxWidth = '375px';\n        break;\n      default:\n        container.style.width = '100%';\n        container.style.maxWidth = '1140px';\n    }\n\n    // Rearrange elements if they don't fit\n    if (deviceView !== 'desktop') {\n      const containerWidth = container.offsetWidth;\n\n      // Adjust elements that go beyond the new container width\n      elements.forEach(element => {\n        const el = document.getElementById(`element-${element.id}`);\n        if (!el) return;\n        const elementRight = element.position.x + el.offsetWidth;\n\n        // If element overflows the container width\n        if (elementRight > containerWidth) {\n          // Calculate new x position to keep it within bounds\n          const newX = Math.max(0, containerWidth - el.offsetWidth);\n\n          // Update element position\n          updateElement(element.id, {\n            position: {\n              ...element.position,\n              x: newX\n            }\n          });\n        }\n      });\n    }\n  }, [deviceView, elements, updateElement]);\n  const handleCanvasClick = e => {\n    // Deselect when clicking on the canvas background\n    if (e.target === e.currentTarget && !isPreviewMode) {\n      setSelectedElement(null);\n    }\n  };\n\n  // This function enforces element boundaries\n  const enforceElementBoundaries = (id, newPosition, elementWidth, elementHeight) => {\n    // Calculate max bounds to keep element within canvas\n    const maxX = canvasBounds.right - canvasBounds.left - elementWidth;\n    const maxY = canvasBounds.bottom - canvasBounds.top - elementHeight;\n\n    // Apply constraints\n    return {\n      x: Math.max(0, Math.min(newPosition.x, maxX)),\n      y: Math.max(0, Math.min(newPosition.y, maxY))\n    };\n  };\n  const handleElementDrag = (id, position, elementWidth, elementHeight) => {\n    if (!isPreviewMode) {\n      // Get constrained position\n      const constrainedPosition = enforceElementBoundaries(id, position, elementWidth, elementHeight);\n      updateElement(id, {\n        position: constrainedPosition\n      });\n    }\n  };\n  const handleDrop = useCallback(e => {\n    e.preventDefault();\n    if (isPreviewMode) return;\n\n    // Get drop position\n    const rect = e.currentTarget.getBoundingClientRect();\n    const position = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    };\n\n    // Check if files were dropped\n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n      const file = e.dataTransfer.files[0];\n\n      // Check if it's an image\n      if (file.type.startsWith('image/')) {\n        const reader = new FileReader();\n        reader.onload = event => {\n          // Create a new image element\n          const newElement = {\n            id: `element-${Date.now()}`,\n            type: 'image',\n            content: event.target.result,\n            style: getDefaultStyle('image'),\n            position: position\n          };\n          addElement(newElement);\n        };\n        reader.readAsDataURL(file);\n      }\n    }\n  }, [isPreviewMode, addElement, getDefaultStyle]);\n  const handleDragOver = useCallback(e => {\n    e.preventDefault();\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: canvasRef,\n    className: `canvas ${isPreviewMode ? 'preview-mode' : ''}`,\n    onClick: handleCanvasClick,\n    onDrop: handleDrop,\n    onDragOver: handleDragOver,\n    children: elements.map(element => /*#__PURE__*/_jsxDEV(Element, {\n      id: `element-${element.id}`,\n      element: element,\n      isSelected: element.id === selectedElement,\n      onSelect: setSelectedElement,\n      onUpdate: (id, updates, isNew = false) => {\n        if (isNew) {\n          // This is for adding a duplicated element\n          addElement(updates);\n        } else {\n          // Normal update\n          updateElement(id, updates);\n        }\n      },\n      onDelete: deleteElement,\n      isPreviewMode: isPreviewMode,\n      canvasBounds: canvasBounds\n    }, element.id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 194,\n      columnNumber: 9\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 186,\n    columnNumber: 5\n  }, this);\n}\n_s(Canvas, \"iUtuzcwJcCRRcp6GOfK7qQqnDoM=\");\n_c = Canvas;\nexport default Canvas;\nvar _c;\n$RefreshReg$(_c, \"Canvas\");","map":{"version":3,"names":["React","useCallback","useRef","useEffect","useState","Element","jsxDEV","_jsxDEV","Canvas","elements","selectedElement","setSelectedElement","updateElement","deleteElement","isPreviewMode","addElement","getDefaultStyle","deviceView","_s","canvasRef","canvasBounds","setCanvasBounds","left","right","top","bottom","width","updateCanvasBounds","current","rect","getBoundingClientRect","window","addEventListener","observer","MutationObserver","observe","document","body","childList","subtree","attributes","attributeFilter","removeEventListener","disconnect","style","paddingBottom","maxBottom","forEach","element","el","getElementById","id","position","y","offsetHeight","Math","max","minHeight","innerHeight","container","parentElement","maxWidth","containerWidth","offsetWidth","elementRight","x","newX","handleCanvasClick","e","target","currentTarget","enforceElementBoundaries","newPosition","elementWidth","elementHeight","maxX","maxY","min","handleElementDrag","constrainedPosition","handleDrop","preventDefault","clientX","clientY","dataTransfer","files","length","file","type","startsWith","reader","FileReader","onload","event","newElement","Date","now","content","result","readAsDataURL","handleDragOver","ref","className","onClick","onDrop","onDragOver","children","map","isSelected","onSelect","onUpdate","updates","isNew","onDelete","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/manikranthbheemineni/PlayGround/Ejoy/Editor engin/src/components/Canvas.jsx"],"sourcesContent":["import React, { useCallback, useRef, useEffect, useState } from 'react';\nimport Element from './Element';\nimport './Canvas.css';\n\nfunction Canvas({ elements, selectedElement, setSelectedElement, updateElement, deleteElement, isPreviewMode, addElement, getDefaultStyle, deviceView }) {\n  const canvasRef = useRef(null);\n  const [canvasBounds, setCanvasBounds] = useState({ left: 0, right: 0, top: null, bottom: null, width: 0 });\n  \n  // Calculate and update canvas boundaries when component mounts or window resizes\n  useEffect(() => {\n    const updateCanvasBounds = () => {\n      if (canvasRef.current) {\n        const rect = canvasRef.current.getBoundingClientRect();\n        \n        // Set bounds based on canvas container dimensions\n        setCanvasBounds({\n          left: rect.left,\n          right: rect.right,\n          // No vertical constraints for infinite scrolling\n          top: null,\n          bottom: null,\n          // Add the width to help with calculations\n          width: rect.width\n        });\n      }\n    };\n    \n    updateCanvasBounds();\n    window.addEventListener('resize', updateCanvasBounds);\n    \n    const observer = new MutationObserver(updateCanvasBounds);\n    observer.observe(document.body, { \n      childList: true, \n      subtree: true,\n      attributes: true,\n      attributeFilter: ['style', 'class']\n    });\n    \n    return () => {\n      window.removeEventListener('resize', updateCanvasBounds);\n      observer.disconnect();\n    };\n  }, []);\n  \n  // Adjust canvas height based on elements and mode\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    \n    if (isPreviewMode) {\n      canvasRef.current.style.paddingBottom = '0';\n    } else {\n      // In edit mode, ensure we have plenty of space at the bottom for adding new elements\n      let maxBottom = 0;\n      elements.forEach(element => {\n        const el = document.getElementById(`element-${element.id}`);\n        if (el) {\n          const bottom = element.position.y + el.offsetHeight;\n          maxBottom = Math.max(maxBottom, bottom);\n        }\n      });\n      \n      // Set minimum height to be greater of viewport height or content + padding\n      const minHeight = Math.max(window.innerHeight, maxBottom + 300);\n      canvasRef.current.style.minHeight = `${minHeight}px`;\n      canvasRef.current.style.paddingBottom = '200px';\n    }\n  }, [elements, isPreviewMode]);\n  \n  // Add a useEffect to handle canvas resizing based on device view\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    \n    const container = canvasRef.current.parentElement;\n    \n    // Set width based on device type\n    switch (deviceView) {\n      case 'desktop':\n        container.style.width = '100%';\n        container.style.maxWidth = '1140px';\n        break;\n      case 'tablet':\n        container.style.width = '768px';\n        container.style.maxWidth = '768px';\n        break;\n      case 'mobile':\n        container.style.width = '375px';\n        container.style.maxWidth = '375px';\n        break;\n      default:\n        container.style.width = '100%';\n        container.style.maxWidth = '1140px';\n    }\n    \n    // Rearrange elements if they don't fit\n    if (deviceView !== 'desktop') {\n      const containerWidth = container.offsetWidth;\n      \n      // Adjust elements that go beyond the new container width\n      elements.forEach(element => {\n        const el = document.getElementById(`element-${element.id}`);\n        if (!el) return;\n        \n        const elementRight = element.position.x + el.offsetWidth;\n        \n        // If element overflows the container width\n        if (elementRight > containerWidth) {\n          // Calculate new x position to keep it within bounds\n          const newX = Math.max(0, containerWidth - el.offsetWidth);\n          \n          // Update element position\n          updateElement(element.id, {\n            position: { ...element.position, x: newX }\n          });\n        }\n      });\n    }\n  }, [deviceView, elements, updateElement]);\n  \n  const handleCanvasClick = (e) => {\n    // Deselect when clicking on the canvas background\n    if (e.target === e.currentTarget && !isPreviewMode) {\n      setSelectedElement(null);\n    }\n  };\n  \n  // This function enforces element boundaries\n  const enforceElementBoundaries = (id, newPosition, elementWidth, elementHeight) => {\n    // Calculate max bounds to keep element within canvas\n    const maxX = canvasBounds.right - canvasBounds.left - elementWidth;\n    const maxY = canvasBounds.bottom - canvasBounds.top - elementHeight;\n    \n    // Apply constraints\n    return {\n      x: Math.max(0, Math.min(newPosition.x, maxX)),\n      y: Math.max(0, Math.min(newPosition.y, maxY))\n    };\n  };\n  \n  const handleElementDrag = (id, position, elementWidth, elementHeight) => {\n    if (!isPreviewMode) {\n      // Get constrained position\n      const constrainedPosition = enforceElementBoundaries(id, position, elementWidth, elementHeight);\n      updateElement(id, { position: constrainedPosition });\n    }\n  };\n  \n  const handleDrop = useCallback((e) => {\n    e.preventDefault();\n    if (isPreviewMode) return;\n    \n    // Get drop position\n    const rect = e.currentTarget.getBoundingClientRect();\n    const position = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    };\n    \n    // Check if files were dropped\n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n      const file = e.dataTransfer.files[0];\n      \n      // Check if it's an image\n      if (file.type.startsWith('image/')) {\n        const reader = new FileReader();\n        reader.onload = (event) => {\n          // Create a new image element\n          const newElement = {\n            id: `element-${Date.now()}`,\n            type: 'image',\n            content: event.target.result,\n            style: getDefaultStyle('image'),\n            position: position\n          };\n          addElement(newElement);\n        };\n        reader.readAsDataURL(file);\n      }\n    }\n  }, [isPreviewMode, addElement, getDefaultStyle]);\n  \n  const handleDragOver = useCallback((e) => {\n    e.preventDefault();\n  }, []);\n  \n  return (\n    <div \n      ref={canvasRef}\n      className={`canvas ${isPreviewMode ? 'preview-mode' : ''}`} \n      onClick={handleCanvasClick}\n      onDrop={handleDrop}\n      onDragOver={handleDragOver}\n    >\n      {elements.map(element => (\n        <Element\n          key={element.id}\n          id={`element-${element.id}`}\n          element={element}\n          isSelected={element.id === selectedElement}\n          onSelect={setSelectedElement}\n          onUpdate={(id, updates, isNew = false) => {\n            if (isNew) {\n              // This is for adding a duplicated element\n              addElement(updates);\n            } else {\n              // Normal update\n              updateElement(id, updates);\n            }\n          }}\n          onDelete={deleteElement}\n          isPreviewMode={isPreviewMode}\n          canvasBounds={canvasBounds}\n        />\n      ))}\n    </div>\n  );\n}\n\nexport default Canvas; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}