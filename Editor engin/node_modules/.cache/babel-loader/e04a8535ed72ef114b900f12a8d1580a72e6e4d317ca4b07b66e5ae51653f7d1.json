{"ast":null,"code":"var _jsxFileName = \"/Users/manikranthbheemineni/PlayGround/Editor engin/src/components/Canvas.jsx\",\n  _s = $RefreshSig$();\nimport React, { useCallback, useRef, useEffect, useState } from 'react';\nimport Element from './Element';\nimport './Canvas.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Canvas({\n  elements,\n  selectedElement,\n  setSelectedElement,\n  updateElement,\n  deleteElement,\n  isPreviewMode,\n  addElement,\n  getDefaultStyle\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  const [canvasBounds, setCanvasBounds] = useState({\n    left: 0,\n    right: 0,\n    top: null,\n    bottom: null,\n    width: 0\n  });\n\n  // Calculate and update canvas boundaries when component mounts or window resizes\n  useEffect(() => {\n    const updateCanvasBounds = () => {\n      if (canvasRef.current) {\n        const rect = canvasRef.current.getBoundingClientRect();\n\n        // Set bounds based on canvas container dimensions\n        setCanvasBounds({\n          left: rect.left,\n          right: rect.right,\n          // No vertical constraints for infinite scrolling\n          top: null,\n          bottom: null,\n          // Add the width to help with calculations\n          width: rect.width\n        });\n      }\n    };\n    updateCanvasBounds();\n    window.addEventListener('resize', updateCanvasBounds);\n    const observer = new MutationObserver(updateCanvasBounds);\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['style', 'class']\n    });\n    return () => {\n      window.removeEventListener('resize', updateCanvasBounds);\n      observer.disconnect();\n    };\n  }, []);\n\n  // Adjust canvas height based on elements and mode\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    if (isPreviewMode) {\n      canvasRef.current.style.paddingBottom = '0';\n    } else {\n      // In edit mode, ensure we have plenty of space at the bottom for adding new elements\n      let maxBottom = 0;\n      elements.forEach(element => {\n        const el = document.getElementById(`element-${element.id}`);\n        if (el) {\n          const bottom = element.position.y + el.offsetHeight;\n          maxBottom = Math.max(maxBottom, bottom);\n        }\n      });\n\n      // Set minimum height to be greater of viewport height or content + padding\n      const minHeight = Math.max(window.innerHeight, maxBottom + 300);\n      canvasRef.current.style.minHeight = `${minHeight}px`;\n      canvasRef.current.style.paddingBottom = '200px';\n    }\n  }, [elements, isPreviewMode]);\n  const handleCanvasClick = e => {\n    // Deselect when clicking on the canvas background\n    if (e.target === e.currentTarget && !isPreviewMode) {\n      setSelectedElement(null);\n    }\n  };\n\n  // This function enforces element boundaries\n  const enforceElementBoundaries = (id, newPosition, elementWidth, elementHeight) => {\n    // Calculate max bounds to keep element within canvas\n    const maxX = canvasBounds.right - canvasBounds.left - elementWidth;\n    const maxY = canvasBounds.bottom - canvasBounds.top - elementHeight;\n\n    // Apply constraints\n    return {\n      x: Math.max(0, Math.min(newPosition.x, maxX)),\n      y: Math.max(0, Math.min(newPosition.y, maxY))\n    };\n  };\n  const handleElementDrag = (id, position, elementWidth, elementHeight) => {\n    if (!isPreviewMode) {\n      // Get constrained position\n      const constrainedPosition = enforceElementBoundaries(id, position, elementWidth, elementHeight);\n      updateElement(id, {\n        position: constrainedPosition\n      });\n    }\n  };\n  const handleDrop = useCallback(e => {\n    e.preventDefault();\n    if (isPreviewMode) return;\n\n    // Get drop position\n    const rect = e.currentTarget.getBoundingClientRect();\n    const position = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    };\n\n    // Check if files were dropped\n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n      const file = e.dataTransfer.files[0];\n\n      // Check if it's an image\n      if (file.type.startsWith('image/')) {\n        const reader = new FileReader();\n        reader.onload = event => {\n          // Create a new image element\n          const newElement = {\n            id: `element-${Date.now()}`,\n            type: 'image',\n            content: event.target.result,\n            style: getDefaultStyle('image'),\n            position: position\n          };\n          addElement(newElement);\n        };\n        reader.readAsDataURL(file);\n      }\n    }\n  }, [isPreviewMode, addElement, getDefaultStyle]);\n  const handleDragOver = useCallback(e => {\n    e.preventDefault();\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: canvasRef,\n    className: `canvas ${isPreviewMode ? 'preview-mode' : ''}`,\n    onClick: handleCanvasClick,\n    onDrop: handleDrop,\n    onDragOver: handleDragOver,\n    children: elements.map(element => /*#__PURE__*/_jsxDEV(Element, {\n      id: `element-${element.id}`,\n      element: element,\n      isSelected: element.id === selectedElement,\n      onSelect: setSelectedElement,\n      onUpdate: (id, updates, isNew = false) => {\n        if (isNew) {\n          // This is for adding a duplicated element\n          addElement(updates);\n        } else {\n          // Normal update\n          updateElement(id, updates);\n        }\n      },\n      onDelete: deleteElement,\n      isPreviewMode: isPreviewMode,\n      canvasBounds: canvasBounds\n    }, element.id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 144,\n      columnNumber: 9\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 136,\n    columnNumber: 5\n  }, this);\n}\n_s(Canvas, \"m9zGV4d7Vca59cTHgrb1H/s81C4=\");\n_c = Canvas;\nexport default Canvas;\nvar _c;\n$RefreshReg$(_c, \"Canvas\");","map":{"version":3,"names":["React","useCallback","useRef","useEffect","useState","Element","jsxDEV","_jsxDEV","Canvas","elements","selectedElement","setSelectedElement","updateElement","deleteElement","isPreviewMode","addElement","getDefaultStyle","_s","canvasRef","canvasBounds","setCanvasBounds","left","right","top","bottom","width","updateCanvasBounds","current","rect","getBoundingClientRect","window","addEventListener","observer","MutationObserver","observe","document","body","childList","subtree","attributes","attributeFilter","removeEventListener","disconnect","style","paddingBottom","maxBottom","forEach","element","el","getElementById","id","position","y","offsetHeight","Math","max","minHeight","innerHeight","handleCanvasClick","e","target","currentTarget","enforceElementBoundaries","newPosition","elementWidth","elementHeight","maxX","maxY","x","min","handleElementDrag","constrainedPosition","handleDrop","preventDefault","clientX","clientY","dataTransfer","files","length","file","type","startsWith","reader","FileReader","onload","event","newElement","Date","now","content","result","readAsDataURL","handleDragOver","ref","className","onClick","onDrop","onDragOver","children","map","isSelected","onSelect","onUpdate","updates","isNew","onDelete","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/manikranthbheemineni/PlayGround/Editor engin/src/components/Canvas.jsx"],"sourcesContent":["import React, { useCallback, useRef, useEffect, useState } from 'react';\nimport Element from './Element';\nimport './Canvas.css';\n\nfunction Canvas({ elements, selectedElement, setSelectedElement, updateElement, deleteElement, isPreviewMode, addElement, getDefaultStyle }) {\n  const canvasRef = useRef(null);\n  const [canvasBounds, setCanvasBounds] = useState({ left: 0, right: 0, top: null, bottom: null, width: 0 });\n  \n  // Calculate and update canvas boundaries when component mounts or window resizes\n  useEffect(() => {\n    const updateCanvasBounds = () => {\n      if (canvasRef.current) {\n        const rect = canvasRef.current.getBoundingClientRect();\n        \n        // Set bounds based on canvas container dimensions\n        setCanvasBounds({\n          left: rect.left,\n          right: rect.right,\n          // No vertical constraints for infinite scrolling\n          top: null,\n          bottom: null,\n          // Add the width to help with calculations\n          width: rect.width\n        });\n      }\n    };\n    \n    updateCanvasBounds();\n    window.addEventListener('resize', updateCanvasBounds);\n    \n    const observer = new MutationObserver(updateCanvasBounds);\n    observer.observe(document.body, { \n      childList: true, \n      subtree: true,\n      attributes: true,\n      attributeFilter: ['style', 'class']\n    });\n    \n    return () => {\n      window.removeEventListener('resize', updateCanvasBounds);\n      observer.disconnect();\n    };\n  }, []);\n  \n  // Adjust canvas height based on elements and mode\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    \n    if (isPreviewMode) {\n      canvasRef.current.style.paddingBottom = '0';\n    } else {\n      // In edit mode, ensure we have plenty of space at the bottom for adding new elements\n      let maxBottom = 0;\n      elements.forEach(element => {\n        const el = document.getElementById(`element-${element.id}`);\n        if (el) {\n          const bottom = element.position.y + el.offsetHeight;\n          maxBottom = Math.max(maxBottom, bottom);\n        }\n      });\n      \n      // Set minimum height to be greater of viewport height or content + padding\n      const minHeight = Math.max(window.innerHeight, maxBottom + 300);\n      canvasRef.current.style.minHeight = `${minHeight}px`;\n      canvasRef.current.style.paddingBottom = '200px';\n    }\n  }, [elements, isPreviewMode]);\n  \n  const handleCanvasClick = (e) => {\n    // Deselect when clicking on the canvas background\n    if (e.target === e.currentTarget && !isPreviewMode) {\n      setSelectedElement(null);\n    }\n  };\n  \n  // This function enforces element boundaries\n  const enforceElementBoundaries = (id, newPosition, elementWidth, elementHeight) => {\n    // Calculate max bounds to keep element within canvas\n    const maxX = canvasBounds.right - canvasBounds.left - elementWidth;\n    const maxY = canvasBounds.bottom - canvasBounds.top - elementHeight;\n    \n    // Apply constraints\n    return {\n      x: Math.max(0, Math.min(newPosition.x, maxX)),\n      y: Math.max(0, Math.min(newPosition.y, maxY))\n    };\n  };\n  \n  const handleElementDrag = (id, position, elementWidth, elementHeight) => {\n    if (!isPreviewMode) {\n      // Get constrained position\n      const constrainedPosition = enforceElementBoundaries(id, position, elementWidth, elementHeight);\n      updateElement(id, { position: constrainedPosition });\n    }\n  };\n  \n  const handleDrop = useCallback((e) => {\n    e.preventDefault();\n    if (isPreviewMode) return;\n    \n    // Get drop position\n    const rect = e.currentTarget.getBoundingClientRect();\n    const position = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    };\n    \n    // Check if files were dropped\n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n      const file = e.dataTransfer.files[0];\n      \n      // Check if it's an image\n      if (file.type.startsWith('image/')) {\n        const reader = new FileReader();\n        reader.onload = (event) => {\n          // Create a new image element\n          const newElement = {\n            id: `element-${Date.now()}`,\n            type: 'image',\n            content: event.target.result,\n            style: getDefaultStyle('image'),\n            position: position\n          };\n          addElement(newElement);\n        };\n        reader.readAsDataURL(file);\n      }\n    }\n  }, [isPreviewMode, addElement, getDefaultStyle]);\n  \n  const handleDragOver = useCallback((e) => {\n    e.preventDefault();\n  }, []);\n  \n  return (\n    <div \n      ref={canvasRef}\n      className={`canvas ${isPreviewMode ? 'preview-mode' : ''}`} \n      onClick={handleCanvasClick}\n      onDrop={handleDrop}\n      onDragOver={handleDragOver}\n    >\n      {elements.map(element => (\n        <Element\n          key={element.id}\n          id={`element-${element.id}`}\n          element={element}\n          isSelected={element.id === selectedElement}\n          onSelect={setSelectedElement}\n          onUpdate={(id, updates, isNew = false) => {\n            if (isNew) {\n              // This is for adding a duplicated element\n              addElement(updates);\n            } else {\n              // Normal update\n              updateElement(id, updates);\n            }\n          }}\n          onDelete={deleteElement}\n          isPreviewMode={isPreviewMode}\n          canvasBounds={canvasBounds}\n        />\n      ))}\n    </div>\n  );\n}\n\nexport default Canvas; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}